#!/bin/bash
# 2026-Jan-24 Jim Fischer <fischerjd@missouri.edu>
# Â© 2024 James D. Fischer
#
# <help_begin>
#
# NAME
#   git-update - performs `git pull' on all remote-tracking branches 
#                associated with a local Git repository
#
# SYNOPSYS
#   git-update [dir]
#   git-update --help
#
# DESCRIPTION
#   Performs a `git pull' operation on all remote-tracking branches
#   associated with the local git repository located in directory 'dir'.
#
#   The optional 'dir' parameter specifies the path to a folder that
#   contains a local Git repository.  If 'dir' is not specified, git-update
#   acts upon the current working directory.
#
#   git-update's workflow is as follows:
#       * CHECK: If 'dir' IS NOT within a local Git repository, exit.
#       * CHECK: If 'dir' is excluded from a local Git repository, exit.
#       * git-fetch
#       * Determine the names of the local Git repository's remote-tracking
#         branches.  If there are no remote-tracking branches, exit.
#       * Save the name of the local Git repository's starting branch.
#       * git-stash all modified and/or untracked files in the local 
#         starting branch.
#       * For each remote-tracking branch:
#           * git-switch to the local branch that corresponds to the 
#             remote-tracking branch.
#           * If the local branch is behind its remote-tracking branch:
#               * Stash all modified and untracked files in the local
#                 branch.
#               * git-pull
#               * Pop any stashed files into the local branch.
#       * Use git-switch to select the starting branch
#       * Perform git-stash pop on the starting branch
#
# OPTIONS
#   -h, --help
#       Displays this script's help information.
#
# INSTALLATION
#   I recommend you use the following procedure to "install" this script:
#       1) $ test -d ~/.local/bin/ || mkdir -p ~/.local/bin/
#       2) $ ln -s ../../git/ece3220/bin/git-update ~/.local/bin/
#       3) Log out and log back in for these changes to take effect.
#
# EXAMPLE
#       $ git update ~/git/ece3220
#       OR,
#       $ cd ~/git/ece3220
#       $ git update
#
# <help_end>
#
set -eu

#source /usr/local/libexec/eceugl-utils/trace

# Program paths
readonly BASENAME=/usr/bin/basename
readonly DIRNAME=/usr/bin/dirname
readonly GETOPT=/usr/bin/getopt
readonly GIT=/usr/bin/git
readonly PAGER=/usr/bin/less
readonly REALPATH=/usr/bin/realpath
readonly SED=/usr/bin/sed


SCRIPT_REALPATH="$("${REALPATH}" "$0")"
readonly SCRIPT_REALPATH

SCRIPT_NAME="$("${BASENAME}" "$SCRIPT_REALPATH")"
readonly SCRIPT_NAME

SCRIPT_DIR="$("${DIRNAME}" "$SCRIPT_REALPATH")"
# shellcheck disable=SC2034
readonly SCRIPT_DIR


#==========================================================================
# _catch_output STDOUT_VARIABLE STDERR_VARIABLE cmd [args...]
#
# @brief Captures simultaneously into variables STDOUT_VARIABLE and
#       STDERR_VARIABLE the stdout and stderr output from command 'cmd'.
# @param[out] STDOUT_VARIABLE (a variable name) The name of a variable that
#       receives the text that 'cmd' writes to stdout.
# @param[out] STDERR_VARIABLE (a variable name) The name of a variable that
#       receives the text that 'cmd' writes to stderr.
# @param[in] cmd (string) The command that's to be executed.
# @param[in] args... (optional,string) The command line arguments, if any,
#       for command 'cmd'.
#
# I'm assuming the copyright holder for this code is the author of this
# post on StackOverflow.com: https://stackoverflow.com/a/41069638/5051940
#==========================================================================

function _catch_output()
{
set +e
    eval "$({
    __2="$(
      { __1="$("${@:3}")"; } 2>&1;
      ret=$?;
      printf '%s=%q\n' "$1" "$__1" >&2;
      exit $ret
      )"
    ret=$?;
    printf '%s=%q\n' "$2" "$__2" >&2;
    printf 'return %q\n' "$ret" >&2;
    } 2>&1 )";
set -e
}
declare -rf _catch_output


#==========================================================================
#  error_exit() exit_status [[error_message] [[extended_message]...]]
#
#  @brief Prints an error message to the standard error output stream and
#       exits.
#  @param[in] exit_status (uint8_t) This script's exit status number.
#  @param[in] error_message (string, optional) An optional string that
#       summarizes the error that caused this script to exit abnormally.
#  @param[in] extended_message (string, optional) A list of zero or more
#       strings that provide extended information regarding the error that
#       caused this script to exit abnormally.
#==========================================================================

function error_exit()
{
    local exit_status
    local error_message
    local error_message_color=''
    local color_reset=''
    local -r BOLD_RED_COLOR='\e[1;31m'
    local -r NO_COLOR='\e[0m'

    exit_status="${1}"
    error_message="${2:-Unspecified error}"

    case "${TERM:-}" in
        *256*) 
            error_message_color="${BOLD_RED_COLOR}"
            color_reset="${NO_COLOR}"
    esac

    # Print the error message
    printf "\n%b:: ERROR ::%b %s\n%s\n" \
        "${error_message_color}" "${color_reset}" \
        "${SCRIPT_NAME}" \
        "${error_message}"

    if [[ $# -gt 2 ]]; then
        # Print each extended message on a separate line
        shift 2
        while [ $# -gt 0 ]
        do
            printf "%s\n" "${1}"
            shift
        done
    fi
    echo

    # Exit
    exit "$exit_status"
} >&2
declare -frx error_exit


#==========================================================================
# git_update()
#
# @param[in] git_repo_directory (string, required) The path to a folder 
#   that contains a Git repository.
# 
# DESCRIPTION
#   The following tasks are performed in order on git_repo_directory:
#   * Save the name of the currently active branch (starting_branch).
#   * Stash starting_branch's uncommitted changes and untracked files.
#   * For each remote-tracking branch, perform these tasks in order:
#     - git switch <branch>
#     - Stash any changed and/or untracked files
#     - git pull
#     - Pop the stashed files, if any
#   * Switch to the starting_branch.
#   * Pop any stashed changes / untracked files in starting_branch.
#
# RETURNS
#   Returns 0 on success.  Otherwise, an error message is printed and a
#   non-zero exit status is returned.
#==========================================================================

function git_update()
{
    local git_repo_directory="${1%/}"
    local branch_name
    local current_branch_files_were_stashed
    local current_branch_name
    local git_repo_directory_realpath
    local local_hash
    local remote_hash
    local remote_tracking_branches
    local starting_branch
    local starting_branch_files_were_stashed

    # If the path string begins with a tilde character '~', replace the
    # tilde with the canonical path to the user's HOME directory.
    # See also:  https://stackoverflow.com/a/27485157/5051940
    git_repo_directory="${git_repo_directory/#\~/${HOME}}"
    git_repo_directory_realpath="$("${REALPATH}" "${git_repo_directory}")"

    echo
    echo "==============================================================="
    echo "  Processing: ${git_repo_directory}"
    if [[ "${git_repo_directory}" != "${git_repo_directory_realpath}" ]]; then
        echo "  Realpath  : ${git_repo_directory_realpath}"
    fi
    echo "==============================================================="


    #----------------------------------------------------------------------
    #  VALIDATION: Ensure folder git_repo_directory exists.
    #----------------------------------------------------------------------

    if [[ ! -d "${git_repo_directory_realpath}" ]]; then
        error_exit 1 "Folder '${git_repo_directory_realpath}' does not exist."
    fi
    
    cd "${git_repo_directory_realpath}"


    #----------------------------------------------------------------------
    #  VALIDATION: Ensure the current working directory resides within a
    #  local Git repository.
    #----------------------------------------------------------------------

    if ! "${GIT}" rev-parse --is-inside-work-tree &> /dev/null; then
        error_exit 1 "Directory '${git_repo_directory_realpath}' is not within a local Git repository."
    fi


    #----------------------------------------------------------------------
    #  VALIDATION: Ensure the current working directory (cwd) IS NOT
    #  excluded from the local Git repository.
    #----------------------------------------------------------------------

    if "${GIT}" check-ignore -q --no-index "${git_repo_directory_realpath}"; then
        error_exit 1 "Directory '${git_repo_directory}' is not part of a local Git repository."
    fi


    #----------------------------------------------------------------------
    #  CHECK: Does this Git repository have remote-tracking branches?
    #----------------------------------------------------------------------

    # Download all commits, files, and references (like branches and tags)
    # from the remote repository into the local repository without changing
    # the current local branches or the current working directory.
    "${GIT}" fetch --all

    # Generate a manifest of this Git repo's remote-tracking branches.
    mapfile -t remote_tracking_branches < \
        <("${GIT}" branch -r 2>/dev/null | "$SED" 's/^[[:space:]]*origin\///' | "$SED" '/^HEAD/d')

    # If this repo has no remote-tracking branches, there's nothing to do.
    if [[ ${#remote_tracking_branches[@]} -eq 0 ]]; then
        return 0
    fi

    #----------------------------------------------------------------------
    #  Get to work: perform git-pull on each remote-tracking branch
    #----------------------------------------------------------------------

    # Save the name of the currently-selected branch
    starting_branch="$("${GIT}" branch --show-current)"
    echo "Starting branch: ${starting_branch}"

    # If the starting branch has changes or untracked files, stash those
    # changes / untracked files before continuing.
    starting_branch_files_were_stashed=false
    if [[ $("${GIT}" status --porcelain) ]]; then
        "${GIT}" stash --include-untracked &>/dev/null
        starting_branch_files_were_stashed=true
    fi

    # Pull the remote-tracking branches into their local branches.
    for branch_name in "${remote_tracking_branches[@]}"; do

        current_branch_name=$("${GIT}" rev-parse --abbrev-ref HEAD)
        if [[ "$branch_name" != "${current_branch_name}" ]]; then
            if ! "${GIT}" switch "${branch_name}"; then
                error_exit 1 "Failed to switch to local branch '${branch_name}'."
            fi
            current_branch_name="${branch_name}"
        fi

        # Get the commit hash of the local branch head
        local_hash="$("${GIT}" rev-parse HEAD)"

        # Get the commit hash of the remote tracking branch head
        remote_hash="$("${GIT}" rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null)"
        
        if [ "${local_hash}" != "${remote_hash}" ]; then

            # CHECK: Is the local branch behind the remote branch?
            if "${GIT}" merge-base --is-ancestor "${local_hash}" "${remote_hash}"; then

                # The local branch is behind the remote. Use git-pull to
                # pull the remote commits to the local branch.

                current_branch_files_were_stashed=false
                if [[ $("${GIT}" status --porcelain) ]]; then
                    "${GIT}" stash --include-untracked
                    current_branch_files_were_stashed=true
                fi

                "${GIT}" pull

                if $current_branch_files_were_stashed; then
                    "${GIT}" stash pop
                fi

            elif "${GIT}" merge-base --is-ancestor "${remote_hash}" "${local_hash}"; then
                _error_exit 1 "The local branch is ahead of the remote branch."
            else
                _error_exit 1 "The local branch has diverged from the remote branch."
            fi

        fi

    done


    #----------------------------------------------------------------------
    #  Restore the starting branch
    #----------------------------------------------------------------------

    if [[ "${current_branch_name}" != "${starting_branch}" ]]; then
        "${GIT}" switch "${starting_branch}"
    fi

    if ${starting_branch_files_were_stashed}; then
        "${GIT}" -c 'color.ui=always' stash pop | "${SED}" '1,2d'
    fi

}
declare -rf git_update


#==========================================================================
# parse_the_command_line "$@"
#==========================================================================

function parse_the_command_line()
{
    # Parameter values for `lopts' and `sopts'
    # X   no operand
    # X:  required operand--e.g., -X required_value, --ex=required_value
    # X:: optional operand--e.g., -X  =OR=  -X value
    local lopts="help"
    local sopts="h"
    local getopt_exit_code
    local getopt_stderr
    local getopt_stdout

set +e
    _catch_output getopt_stdout getopt_stderr \
        "${GETOPT}" -o "${sopts}" -l "${lopts}" -a -n$-1 -s bash -- "$@"
    getopt_exit_code=$?
set -e

    if [[ $getopt_exit_code -ne 0 ]]; then
        error_exit "${getopt_exit_code}" "${getopt_stderr}"
    fi

    eval set -- "${getopt_stdout}"

    while [[ $# -gt 0 ]]
    do
        case "$1" in
            -h|--help) cloHelpRequested=true; break ;;
            --) if [[ $# -ge 2 ]]; then
                    cloGitRepoDirectory="${2}"
                    # Discard everything after the initial 'dir' argument
                    shift $(($# - 1))
                fi 
                ;;
            *) : ;; # unsupported -Y options
        esac
        shift
    done
}
declare -rf parse_the_command_line


#==========================================================================
#  main()
#==========================================================================

#--------------------------------------------------------------------------
#  Parse the command line
#--------------------------------------------------------------------------

# The default git repository directory is the current working directory. 
cloGitRepoDirectory="$(/usr/bin/pwd)"
cloHelpRequested=false

parse_the_command_line "$@"


#--------------------------------------------------------------------------
#  If the user requested help, display the help information and exit.
#--------------------------------------------------------------------------

if $cloHelpRequested; then
    export LESS="--quit-if-one-screen --prompt=\ Help for ${SCRIPT_NAME}\: ?ltline %lt?L/%L.:byte %bB?s/%s..?e (END):?pB %pB\%.. (press h for help or q to quit)\ "
    "${SED}" -n -e '/help_begin/,/help_end/{ /help_begin/d; /help_end/q; s/#\( \)\?//; p }' "$0" \
        | "${PAGER}"
    exit 0
fi


#--------------------------------------------------------------------------
#  Update the specified Git repository 
#--------------------------------------------------------------------------

git_update "${cloGitRepoDirectory}"

